#!/usr/bin/env bash
#
# tagging_bash.sh - A bash-native file tagging system
#
# This script provides universal file tagging across all directories with
# fuzzy search, hierarchical tags, and programmatic API integration.
#

set -euo pipefail

# Prevent multiple sourcing
if [[ -n "${_TAGG_SCRIPT_LOADED:-}" ]]; then
    return 0
fi
readonly _TAGG_SCRIPT_LOADED=true

# ============================================================================
# Constants
# ============================================================================

readonly SCRIPT_NAME="tagg"
readonly SCRIPT_VERSION="0.1.0"
readonly CONFIG_DIR="${HOME}/.tagging_bash"
readonly TAGS_FILE="${CONFIG_DIR}/tags.md"
readonly CONFIG_FILE="${CONFIG_DIR}/config.sh"
readonly LOCK_FILE="${CONFIG_DIR}/.lock"

# Default configuration
readonly DEFAULT_TAG_SEPARATOR="."
readonly DEFAULT_FUZZY_THRESHOLD=0.8

# Exit codes (POSIX compliant)
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_USAGE=2
readonly EXIT_NOT_FOUND=3

# ============================================================================
# Utility Functions
# ============================================================================

# error() - Consistent error reporting to stderr
error() {
    echo "Error: $*" >&2
    return "${EXIT_ERROR}"
}

# info() - Informational messages to stdout
info() {
    echo "$*"
}

# debug() - Debug messages if DEBUG is set
debug() {
    if [[ -n "${DEBUG:-}" ]]; then
        echo "DEBUG: $*" >&2
    fi
}

# validate_tag_name() - Validate tag name according to rules
validate_tag_name() {
    local tag="$1"

    # Tag naming rules: letters, numbers, underscores, hyphens, separator
    if [[ ! "$tag" =~ ^[a-zA-Z0-9_.-]+$ ]]; then
        error "Invalid tag name '$tag': only letters, numbers, underscores, hyphens, and dots allowed"
        return 1
    fi

    # Max length 50 characters
    if [[ ${#tag} -gt 50 ]]; then
        error "Tag name '$tag' too long: maximum 50 characters"
        return 1
    fi

    return 0
}

# validate_file_path() - Validate file path exists and is readable
validate_file_path() {
    local file_path="$1"

    if [[ ! -f "$file_path" ]]; then
        error "File does not exist: $file_path"
        return 1
    fi

    if [[ ! -r "$file_path" ]]; then
        error "File not readable: $file_path"
        return 1
    fi

    return 0
}

# acquire_lock() - Acquire file lock for concurrent access
acquire_lock() {
    if ! command -v flock >/dev/null 2>&1; then
        error "flock command not available for file locking"
        return 1
    fi

    exec 200>"$LOCK_FILE"
    if ! flock -n 200; then
        error "Another instance of $SCRIPT_NAME is running"
        return 1
    fi
}

# release_lock() - Release file lock
release_lock() {
    flock -u 200 2>/dev/null || true
}

# load_config() - Load user configuration
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi

    # Set defaults if not configured
    TAG_SEPARATOR="${TAG_SEPARATOR:-$DEFAULT_TAG_SEPARATOR}"
    FUZZY_THRESHOLD="${FUZZY_THRESHOLD:-$DEFAULT_FUZZY_THRESHOLD}"
}

# save_config() - Save configuration
save_config() {
    mkdir -p "$CONFIG_DIR"

    cat > "$CONFIG_FILE" << EOF
# tagging_bash configuration
TAG_SEPARATOR="${TAG_SEPARATOR:-$DEFAULT_TAG_SEPARATOR}"
FUZZY_THRESHOLD="${FUZZY_THRESHOLD:-$DEFAULT_FUZZY_THRESHOLD}"
EOF
}

# ============================================================================
# Core Tag Functions
# ============================================================================

# load_tags() - Load tags from markdown file into associative arrays
load_tags() {
    # Initialize associative arrays
    declare -gA file_tags=()
    declare -gA tag_files=()

    if [[ ! -f "$TAGS_FILE" ]]; then
        debug "Tags file does not exist: $TAGS_FILE"
        return 0
    fi

    local current_file=""
    local in_file_section=false

    while IFS= read -r line; do
        # Check for file header
        if [[ "$line" =~ ^#\ (.+)$ ]]; then
            current_file="${BASH_REMATCH[1]}"
            in_file_section=true
            continue
        fi

        # Check for tag list item
        if [[ "$in_file_section" == true && "$line" =~ ^-\ (.+)$ ]]; then
            local tag="${BASH_REMATCH[1]}"
            if [[ -n "$current_file" && -n "$tag" ]]; then
                # Add to file_tags
                if [[ -z "${file_tags[$current_file]:-}" ]]; then
                    file_tags["$current_file"]="$tag"
                else
                    file_tags["$current_file"]="${file_tags[$current_file]}|$tag"
                fi

                # Add to tag_files
                if [[ -z "${tag_files[$tag]:-}" ]]; then
                    tag_files["$tag"]="$current_file"
                else
                    tag_files["$tag"]="${tag_files[$tag]}|$current_file"
                fi
            fi
        fi
    done < "$TAGS_FILE"

    debug "Loaded ${#file_tags[@]} files and ${#tag_files[@]} unique tags"
}

# validate_database() - Validate database integrity
validate_database() {
    if [[ ! -f "$TAGS_FILE" ]]; then
        debug "Tags file does not exist, integrity OK"
        return 0
    fi

    # Try to load and parse
    declare -A temp_file_tags=()
    declare -A temp_tag_files=()

    local current_file=""
    local in_file_section=false

    while IFS= read -r line; do
        # Check for file header
        if [[ "$line" =~ ^#\ (.+)$ ]]; then
            current_file="${BASH_REMATCH[1]}"
            in_file_section=true
            continue
        fi

        # Check for tag list item
        if [[ "$in_file_section" == true && "$line" =~ ^-\ (.+)$ ]]; then
            local tag="${BASH_REMATCH[1]}"
            if [[ -n "$current_file" && -n "$tag" ]]; then
                # Add to temp_file_tags
                if [[ -z "${temp_file_tags[$current_file]:-}" ]]; then
                    temp_file_tags["$current_file"]="$tag"
                else
                    temp_file_tags["$current_file"]="${temp_file_tags[$current_file]}|$tag"
                fi

                # Add to temp_tag_files
                if [[ -z "${temp_tag_files[$tag]:-}" ]]; then
                    temp_tag_files["$tag"]="$current_file"
                else
                    temp_tag_files["$tag"]="${temp_tag_files[$tag]}|$current_file"
                fi
            fi
        fi
    done < "$TAGS_FILE"

    # Check consistency: every file in file_tags should be in tag_files
    for file in "${!temp_file_tags[@]}"; do
        local tags="${temp_file_tags[$file]}"
        IFS='|' read -ra tag_array <<< "$tags"
        for tag in "${tag_array[@]}"; do
            if [[ ! "${temp_tag_files[$tag]:-}" =~ (^|\|)$file($|\|) ]]; then
                error "Database integrity error: file $file has tag $tag but tag $tag does not reference file"
                return 1
            fi
        done
    done

    # Check reverse
    for tag in "${!temp_tag_files[@]}"; do
        local files="${temp_tag_files[$tag]}"
        IFS='|' read -ra file_array <<< "$files"
        for file in "${file_array[@]}"; do
            if [[ ! "${temp_file_tags[$file]:-}" =~ (^|\|)$tag($|\|) ]]; then
                error "Database integrity error: tag $tag references file $file but file $file does not have tag"
                return 1
            fi
        done
    done

    debug "Database integrity validated"
    return 0
}

# save_tags() - Save tags from associative arrays to markdown file
save_tags() {
    mkdir -p "$CONFIG_DIR"

    # Create temporary file
    local temp_file
    temp_file=$(mktemp)

    # Sort files for consistent output
    local sorted_files
    mapfile -t sorted_files < <(printf '%s\n' "${!file_tags[@]}" | sort)

    for file_path in "${sorted_files[@]}"; do
        echo "# $file_path" >> "$temp_file"

        # Split tags and sort them
        local tags="${file_tags[$file_path]}"
        IFS='|' read -ra tag_array <<< "$tags"
        local sorted_tags
        mapfile -t sorted_tags < <(printf '%s\n' "${tag_array[@]}" | sort)

        for tag in "${sorted_tags[@]}"; do
            echo "- $tag" >> "$temp_file"
        done

        echo "" >> "$temp_file"
    done

    # Atomic write
    mv "$temp_file" "$TAGS_FILE"
    debug "Saved tags to $TAGS_FILE"
}

# ============================================================================
# Command Functions
# ============================================================================

# cmd_install() - Install the tool
cmd_install() {
    local was_installed=false
    if [[ -d "$CONFIG_DIR" && -f "$CONFIG_FILE" && -f "$TAGS_FILE" ]]; then
        was_installed=true
        info "Upgrading $SCRIPT_NAME..."
    else
        info "Installing $SCRIPT_NAME..."
    fi

    # Create config directory
    mkdir -p "$CONFIG_DIR"

    # Create initial config if not exists
    if [[ ! -f "$CONFIG_FILE" ]]; then
        save_config
    fi

    # Create empty tags file if not exists
    if [[ ! -f "$TAGS_FILE" ]]; then
        touch "$TAGS_FILE"
    fi

    # Install bash completion to user directory
    local completion_file="$CONFIG_DIR/completion.bash"
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    if [[ -f "$script_dir/completion.bash" ]]; then
        if cp "$script_dir/completion.bash" "$completion_file" 2>/dev/null; then
            info "Bash completion installed to $completion_file"
            info "To enable tab completion permanently, we need to add a source line to your ~/.bashrc."
            echo -n "Add tab completion source line to ~/.bashrc? (y/n): "
            read -r response
            if [[ "$response" =~ ^[Yy]$ ]]; then
                local bashrc_file="$HOME/.bashrc"
                local source_line="source $completion_file"
                if [[ -f "$bashrc_file" ]] && ! grep -q "$source_line" "$bashrc_file" 2>/dev/null; then
                    echo "$source_line" >> "$bashrc_file"
                    info "Added tab completion to $bashrc_file"
                elif [[ ! -f "$bashrc_file" ]]; then
                    echo "$source_line" > "$bashrc_file"
                    info "Created $bashrc_file with tab completion"
                else
                    info "Tab completion source line already in $bashrc_file"
                fi
            fi
            # Source it for current session regardless
            if [[ -f "$completion_file" ]]; then
                source "$completion_file"
                info "Tab completion enabled for current session"
            fi
        else
            info "Warning: Could not install bash completion (permission denied)"
        fi
    else
        info "Warning: completion.bash not found, tab completion not installed"
    fi

    # Install script to ~/.tagging_bash/bin for easy access
    local bin_dir="$CONFIG_DIR/bin"
    local script_path
    script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    if mkdir -p "$bin_dir" 2>/dev/null && cp "$script_path" "$bin_dir/tagg" 2>/dev/null; then
        chmod +x "$bin_dir/tagg"
        info "Installed $SCRIPT_NAME to $bin_dir/tagg"
        if [[ ":$PATH:" != *":$bin_dir:"* ]]; then
            info "To use $SCRIPT_NAME, we need to add $bin_dir to your PATH."
            # Ask for permission to modify .bashrc
            echo -n "Modify ~/.bashrc to add $bin_dir to PATH permanently? (y/n): "
            read -r response
            if [[ "$response" =~ ^[Yy]$ ]]; then
                local bashrc_file="$HOME/.bashrc"
                local path_line="export PATH=\"\$PATH:$bin_dir\""
                if [[ -f "$bashrc_file" ]]; then
                    if ! grep -q "$path_line" "$bashrc_file" 2>/dev/null; then
                        echo "$path_line" >> "$bashrc_file"
                        info "Added $bin_dir to $bashrc_file"
                    else
                        info "$bin_dir already in $bashrc_file"
                    fi
                else
                    echo "$path_line" > "$bashrc_file"
                    info "Created $bashrc_file with PATH configuration"
                fi
                info "Run 'source ~/.bashrc' to apply PATH changes immediately"
            else
                info "Run this command to enable $SCRIPT_NAME in current session:"
                info "  export PATH=\"\$PATH:$bin_dir\""
                info "To make permanent: echo 'export PATH=\"\$PATH:$bin_dir\"' >> ~/.bashrc"
            fi
        fi
    else
        info ""
        info "To use $SCRIPT_NAME globally, either:"
        info "  1. Add $(pwd) to your PATH: export PATH=\"\$PATH:$(pwd)\""
        info "  2. Run with full path: $(pwd)/tagg"
        info "  3. Copy to a directory in your PATH (e.g., ~/bin)"
    fi

    info "$SCRIPT_NAME ready!"
    info "Configuration directory: $CONFIG_DIR"
    info "Tags database: $TAGS_FILE"
}

# cmd_uninstall() - Uninstall the tool
cmd_uninstall() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        error "Not installed"
        return 1
    fi

    info "Uninstalling $SCRIPT_NAME..."

    # Remove config directory
    rm -rf "$CONFIG_DIR"

    # Remove bash completion
    rm -f "$CONFIG_DIR/completion.bash"

    # Remove script from ~/.tagging_bash/bin
    local bin_dir="$CONFIG_DIR/bin"
    if [[ -f "$bin_dir/tagg" ]]; then
        rm -f "$bin_dir/tagg"
        # Try to remove the bin directory if empty
        rmdir "$bin_dir" 2>/dev/null && info "Removed $bin_dir directory" || info "Removed tagg script from $bin_dir"
    fi

    # Remove PATH from .bashrc
    local bashrc_file="$HOME/.bashrc"
    local bin_dir="$CONFIG_DIR/bin"
    local path_line="export PATH=\"\$PATH:$bin_dir\""
    if [[ -f "$bashrc_file" ]]; then
        # Create a temp file without the PATH line
        local temp_file
        temp_file=$(mktemp)
        grep -v "$path_line" "$bashrc_file" > "$temp_file" 2>/dev/null || true
        mv "$temp_file" "$bashrc_file" 2>/dev/null || rm -f "$temp_file"
        info "Removed PATH configuration from $bashrc_file"
    fi

    # Remove completion from .bashrc
    local bashrc_file="$HOME/.bashrc"
    local completion_file="$CONFIG_DIR/completion.bash"
    local source_line="source $completion_file"
    if [[ -f "$bashrc_file" ]]; then
        # Create a temp file without the source line
        local temp_file
        temp_file=$(mktemp)
        grep -v "$source_line" "$bashrc_file" > "$temp_file" 2>/dev/null || true
        mv "$temp_file" "$bashrc_file" 2>/dev/null || rm -f "$temp_file"
        info "Removed completion configuration from $bashrc_file"
    fi

    info "$SCRIPT_NAME uninstalled successfully!"
    info "Note: Restart your shell or run this command to remove $CONFIG_DIR/bin from PATH:"
    info "  export PATH=\"\$(echo \"\$PATH\" | sed 's|:$CONFIG_DIR/bin||g; s|^$CONFIG_DIR/bin:||g')\""
}

# cmd_add() - Add tags to files
cmd_add() {
    local files=()
    local tags=()

    # Parse arguments: all args are files or tags
    # Files are those that exist as files, tags are the rest
    for arg in "$@"; do
        if [[ -f "$arg" ]]; then
            files+=("$arg")
        else
            tags+=("$arg")
        fi
    done

    if [[ ${#files[@]} -eq 0 ]]; then
        error "At least one file required"
        return "$EXIT_USAGE"
    fi

    if [[ ${#tags[@]} -eq 0 ]]; then
        error "At least one tag required"
        return "$EXIT_USAGE"
    fi

    # Validate files
    for file in "${files[@]}"; do
        if ! validate_file_path "$file"; then
            return 1
        fi
    done

    # Validate tags
    for tag in "${tags[@]}"; do
        if ! validate_tag_name "$tag"; then
            return 1
        fi
    done

    # Deduplicate tags
    local unique_tags=()
    for tag in "${tags[@]}"; do
        local duplicate=false
        for existing in "${unique_tags[@]}"; do
            if [[ "$tag" == "$existing" ]]; then
                duplicate=true
                break
            fi
        done
        if [[ "$duplicate" == false ]]; then
            unique_tags+=("$tag")
        fi
    done
    tags=("${unique_tags[@]}")

    # Load existing tags
    load_tags

    # Check for duplicates first
    local has_duplicates=false
    for file_path in "${files[@]}"; do
        for tag in "${tags[@]}"; do
            local existing_tags="${file_tags[$file_path]:-}"
            if [[ "$existing_tags" =~ (^|\|)$tag($|\|) ]]; then
                error "Tag '$tag' already exists for $file_path"
                has_duplicates=true
            fi
        done
    done

    if [[ "$has_duplicates" == true ]]; then
        return 1
    fi

    # Add tags to each file
    local total_added=0
    for file_path in "${files[@]}"; do
        local added=()
        for tag in "${tags[@]}"; do
            # Add to file_tags
            local existing_tags="${file_tags[$file_path]:-}"
            if [[ -z "$existing_tags" ]]; then
                file_tags["$file_path"]="$tag"
            else
                file_tags["$file_path"]="${existing_tags}|${tag}"
            fi

            # Add to tag_files
            local existing_files="${tag_files[$tag]:-}"
            if [[ -z "$existing_files" ]]; then
                tag_files["$tag"]="$file_path"
            else
                tag_files["$tag"]="${existing_files}|${file_path}"
            fi

            added+=("$tag")
        done

        if [[ ${#files[@]} -eq 1 ]]; then
            info "Added tags to $file_path: ${added[*]}"
        fi

        total_added=$((total_added + ${#added[@]}))
    done

    if [[ ${#files[@]} -gt 1 ]]; then
        info "Tagged ${#files[@]} files with: ${tags[*]}"
    fi

    # Save tags
    save_tags
}

# cmd_remove() - Remove tags from files
cmd_remove() {
    local file_path="$1"
    local tag="$2"

    if [[ $# -ne 2 ]]; then
        error "Usage: $SCRIPT_NAME remove <file> <tag>"
        return "$EXIT_USAGE"
    fi

    # Validate file
    if ! validate_file_path "$file_path"; then
        return 1
    fi

    # Validate tag
    if ! validate_tag_name "$tag"; then
        return 1
    fi

    # Load existing tags
    load_tags

    # Check if tag exists on file
    local existing_tags="${file_tags[$file_path]:-}"
    if [[ -z "$existing_tags" ]] || [[ ! "$existing_tags" =~ (^|\|)$tag($|\|) ]]; then
        error "Tag '$tag' not found on file $file_path"
        return 1
    fi

    # Remove tag from file_tags
    if [[ "$existing_tags" == "$tag" ]]; then
        # Only tag
        unset "file_tags[$file_path]"
    else
        # Remove from pipe-separated list
        local new_tags
        new_tags=$(echo "$existing_tags" | sed "s/|$tag|/|/g; s/^$tag|//; s/|$tag$//; s/^$tag$//")
        file_tags["$file_path"]="$new_tags"
    fi

    # Remove file from tag_files
    local existing_files="${tag_files[$tag]:-}"
    if [[ "$existing_files" == "$file_path" ]]; then
        # Only file
        unset "tag_files[$tag]"
    else
        # Remove from pipe-separated list
        local new_files
        new_files=$(echo "$existing_files" | sed "s/|$file_path|/|/g; s/^$file_path|//; s/|$file_path$//; s/^$file_path$//")
        tag_files["$tag"]="$new_files"
    fi

    # Save tags
    save_tags

    # Validate database integrity
    if ! validate_database; then
        error "Database integrity validation failed after remove operation"
        return 1
    fi

    # Confirmation
    info "Removed tag '$tag' from $file_path"
}

# cmd_edit() - Edit (replace) a tag on a file
cmd_edit() {
    local file_path="$1"
    local old_tag="$2"
    local new_tag="$3"

    if [[ $# -ne 3 ]]; then
        error "Usage: $SCRIPT_NAME edit <file> <old-tag> <new-tag>"
        return "$EXIT_USAGE"
    fi

    # Validate file
    if ! validate_file_path "$file_path"; then
        return 1
    fi

    # Validate tags
    if ! validate_tag_name "$old_tag"; then
        return 1
    fi

    if ! validate_tag_name "$new_tag"; then
        return 1
    fi

    # Load existing tags
    load_tags

    # Check if old_tag exists on file
    local existing_tags="${file_tags[$file_path]:-}"
    if [[ -z "$existing_tags" ]] || [[ ! "$existing_tags" =~ (^|\|)$old_tag($|\|) ]]; then
        error "Tag '$old_tag' not found on file $file_path"
        return 1
    fi

    # Check if new_tag is the same as old_tag
    if [[ "$old_tag" == "$new_tag" ]]; then
        error "Old tag and new tag are the same"
        return 1
    fi

    # Check if new_tag already exists on file (prevent duplicates)
    if [[ "$existing_tags" =~ (^|\|)$new_tag($|\|) ]]; then
        error "Tag '$new_tag' already exists on file $file_path"
        return 1
    fi

    # Escape special regex characters in old_tag (. is the only special char allowed in tags)
    local escaped_old_tag=$(echo "$old_tag" | sed 's/\./\\./g')

    # Remove old_tag from file_tags
    if [[ "$existing_tags" == "$old_tag" ]]; then
        # Only tag
        unset "file_tags[$file_path]"
    else
        # Remove from pipe-separated list
        local new_tags
        new_tags=$(echo "$existing_tags" | sed "s/|$escaped_old_tag|/|/g; s/^$escaped_old_tag|//; s/|$escaped_old_tag$//; s/^$escaped_old_tag$//")
        file_tags["$file_path"]="$new_tags"
    fi

    # Remove file from tag_files for old_tag
    local existing_files_old="${tag_files[$old_tag]:-}"
    if [[ "$existing_files_old" == "$file_path" ]]; then
        # Only file
        unset "tag_files[$old_tag]"
    else
        # Remove from pipe-separated list
        local new_files_old
        new_files_old=$(echo "$existing_files_old" | sed "s/|$file_path|/|/g; s/^$file_path|//; s/|$file_path$//; s/^$file_path$//")
        tag_files["$old_tag"]="$new_files_old"
    fi

    # Add new_tag to file_tags
    local updated_tags="${file_tags[$file_path]:-}"
    if [[ -z "$updated_tags" ]]; then
        file_tags["$file_path"]="$new_tag"
    else
        file_tags["$file_path"]="${updated_tags}|${new_tag}"
    fi

    # Add file to tag_files for new_tag
    local existing_files_new="${tag_files[$new_tag]:-}"
    if [[ -z "$existing_files_new" ]]; then
        tag_files["$new_tag"]="$file_path"
    else
        tag_files["$new_tag"]="${existing_files_new}|${file_path}"
    fi

    # Save tags
    save_tags

    # Validate database integrity
    if ! validate_database; then
        error "Database integrity validation failed after edit operation"
        return 1
    fi

    # Confirmation
    info "Replaced tag '$old_tag' with '$new_tag' on $file_path"
}

# cmd_list() - List tags for a file or all distinct tags globally
cmd_list() {
    if [[ $# -gt 1 ]]; then
        error "Usage: $SCRIPT_NAME list [file]"
        return "$EXIT_USAGE"
    fi

    # Load existing tags
    load_tags

    if [[ $# -eq 0 ]]; then
        # List all distinct tags globally
        if [[ ${#tag_files[@]} -eq 0 ]]; then
            info "No tags found"
            return 0
        fi

        # Collect all unique tags
        local all_tags=()
        for tag in "${!tag_files[@]}"; do
            all_tags+=("$tag")
        done

        # Sort tags
        local sorted_tags
        mapfile -t sorted_tags < <(printf '%s\n' "${all_tags[@]}" | sort)

        info "All distinct tags:"
        for tag in "${sorted_tags[@]}"; do
            echo "  $tag"
        done
    else
        # List tags for specific file
        local file_path="$1"

        # Validate file
        if ! validate_file_path "$file_path"; then
            return 1
        fi

        local tags="${file_tags[$file_path]:-}"
        if [[ -z "$tags" ]]; then
            info "No tags found for $file_path"
            return 0
        fi

        # Split and sort tags
        IFS='|' read -ra tag_array <<< "$tags"
        local sorted_tags
        mapfile -t sorted_tags < <(printf '%s\n' "${tag_array[@]}" | sort)

        info "Tags for $file_path:"
        for tag in "${sorted_tags[@]}"; do
            echo "  $tag"
        done
    fi
}

# cmd_search() - Search for files by tag(s)
cmd_search() {
    if [[ $# -eq 0 ]]; then
        error "Usage: $SCRIPT_NAME search <tag> [tag2 ...] [--dir <directory>]"
        return "$EXIT_USAGE"
    fi

    local search_tags=()
    local search_dir=""
    local parsing_options=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dir)
                if [[ $# -lt 2 ]]; then
                    error "--dir requires a directory argument"
                    return "$EXIT_USAGE"
                fi
                search_dir="$2"
                shift 2
                ;;
            --*)
                error "Unknown option: $1"
                return "$EXIT_USAGE"
                ;;
            *)
                search_tags+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#search_tags[@]} -eq 0 ]]; then
        error "At least one tag required for search"
        return "$EXIT_USAGE"
    fi

    # Validate tags
    for tag in "${search_tags[@]}"; do
        if ! validate_tag_name "$tag"; then
            return 1
        fi
    done

    # Load existing tags
    load_tags

    # Perform search
    local matches=()
    local start_time
    start_time=$(date +%s%N 2>/dev/null || echo "0")

    # For each file that has tags
    for file_path in "${!file_tags[@]}"; do
        # Check directory filter
        if [[ -n "$search_dir" ]]; then
            if [[ "$file_path" != "$search_dir"/* ]]; then
                continue
            fi
        fi

        local file_tags_str="${file_tags[$file_path]}"
        local has_all_tags=true

        # Check if file has all search tags
        for search_tag in "${search_tags[@]}"; do
            if [[ ! "$file_tags_str" =~ (^|\|)$search_tag($|\|) ]]; then
                has_all_tags=false
                break
            fi
        done

        if [[ "$has_all_tags" == true ]]; then
            matches+=("$file_path")
        fi
    done

    # Calculate timing
    local end_time
    end_time=$(date +%s%N 2>/dev/null || echo "0")
    local duration_ms=$(( (end_time - start_time) / 1000000 ))

    # Display results
    if [[ ${#matches[@]} -eq 0 ]]; then
        info "No files found with tags: ${search_tags[*]}"
        return 0
    fi

    info "Found ${#matches[@]} file(s) with tags: ${search_tags[*]}"
    if [[ -n "$search_dir" ]]; then
        info "Search limited to directory: $search_dir"
    fi
    info "Search completed in ${duration_ms}ms"
    echo ""

    for file_path in "${matches[@]}"; do
        echo "$file_path"
        # Show all tags for this file
        local file_tags_str="${file_tags[$file_path]}"
        IFS='|' read -ra tag_array <<< "$file_tags_str"
        local sorted_tags
        mapfile -t sorted_tags < <(printf '%s\n' "${tag_array[@]}" | sort)
        echo "  Tags: ${sorted_tags[*]}"
        echo ""
    done
}

# cmd_help() - Show help
cmd_help() {
    cat << EOF
$SCRIPT_NAME $SCRIPT_VERSION - A bash-native file tagging system

 USAGE:
     $SCRIPT_NAME <command> [options]

    COMMANDS:
        install         Install $SCRIPT_NAME
        uninstall       Uninstall $SCRIPT_NAME
        add <files> <tags>    Add tags to one or more files
        remove <file> <tag>   Remove a tag from a file
        edit <file> <old-tag> <new-tag>   Replace a tag on a file
        list [file]      List all tags or tags for a specific file
        search <tags>    Search for files by tag(s)
        help            Show this help message

   EXAMPLES:
       $SCRIPT_NAME install
       $SCRIPT_NAME add script.sh bash utility
       $SCRIPT_NAME remove script.sh bash
       $SCRIPT_NAME edit script.sh bash shell
       $SCRIPT_NAME list
       $SCRIPT_NAME list script.sh
       $SCRIPT_NAME help

 For more information, see the README.md file.
EOF
}

# ============================================================================
# Main Function
# ============================================================================

main() {
    local command=""

    # Load configuration
    load_config

    # Acquire lock for operations that modify data
    # Note: This is a basic implementation; more sophisticated locking may be needed

    # Parse command
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit "$EXIT_USAGE"
    fi

    command="$1"
    shift

    case "$command" in
        install)
            cmd_install "$@"
            ;;
        uninstall)
            cmd_uninstall "$@"
            ;;
        add)
            acquire_lock
            cmd_add "$@"
            release_lock
            ;;
        remove)
            acquire_lock
            cmd_remove "$@"
            release_lock
            ;;
        edit)
            acquire_lock
            cmd_edit "$@"
            release_lock
            ;;
        list)
            cmd_list "$@"
            ;;
        search)
            cmd_search "$@"
            ;;
        help|--help|-h)
            cmd_help "$@"
            ;;
        *)
            error "Unknown command: $command"
            echo "" >&2
            cmd_help >&2
            exit "$EXIT_USAGE"
            ;;
    esac
}

# Run main function with all arguments if not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi